using Medallion.OData.Client;
using Medallion.OData.Trees;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Data.SqlClient;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace Medallion.OData.Sql
{
    /// <summary>
    /// Implements <see cref="DatabaseProvider"/> for MS SQLSERVER
    /// </summary>
    public class SqlDatabaseProvider : DatabaseProvider
    {
        /// <summary>
        /// Represents SqlServer versions that altered syntax in a way that affects SQL generation
        /// </summary>
        public enum Version
        {
            /// <summary>
            /// Use for versions 2008 and below
            /// </summary>
            Sql2008,
            /// <summary>
            /// Use for versions 2012 and above
            /// </summary>
            Sql2012,
        }

        private readonly Lazy<Version> version;
        private readonly Func<SqlConnection> connectionFactory;
        private readonly bool providerOwnsConnection;

        /// <summary>
        /// Constructs a provider which will connect using the given <paramref name="connectionStringFactory"/> to generate connection strings
        /// </summary>
        /// <param name="connectionStringFactory">a function which generates a connection string</param>
        /// <param name="version">optionally specifies the server version</param>
        public SqlDatabaseProvider(Func<string> connectionStringFactory, Version? version = null)
            : this(() => new SqlConnection(connectionStringFactory()), providerOwnsConnection: true, version: version)
        {
            Throw.IfNull(connectionStringFactory, "connectionStringFactory");
        }

        /// <summary>
        /// Constructs a provider which will connect using the given <paramref name="connectionFactory"/> to generate <see cref="SqlConnection"/>s
        /// </summary>
        /// <param name="connectionFactory">a function which generates a SqlConnectino</param>
        /// <param name="providerOwnsConnection">if true, the generated connections will be disposed by the provider after use. Defaults to true</param>
        /// <param name="version">optionally specifies the server version</param>
        public SqlDatabaseProvider(Func<SqlConnection> connectionFactory, bool providerOwnsConnection = true, Version? version = null)
        {
            Throw.IfNull(connectionFactory, "connectionFactory");

            this.connectionFactory = connectionFactory;
            this.providerOwnsConnection = providerOwnsConnection;
            this.version = new Lazy<Version>(() => version ?? this.GetVersion());
        }

        private ConnectionHelper GetConnection()
        {
            var connection = this.connectionFactory();
            Throw<InvalidOperationException>.If(connection == null, "The connection generated by the factory was null");
            return new ConnectionHelper(connection, this.providerOwnsConnection);
        }

        private class ConnectionHelper : IDisposable
        {
            private readonly bool ownsConnection;

            public ConnectionHelper(SqlConnection connection, bool ownsConnection)
            {
                this.Connection = connection;
                this.ownsConnection = ownsConnection;
            }

            public SqlConnection Connection { get; private set; }

            public void Dispose()
            {
                var connection = this.Connection;
                if (connection != null)
                {
                    if (this.ownsConnection)
                    {
                        connection.Dispose();
                    }
                    this.Connection = null;
                }
            }
        }

        private Version GetVersion()
        {
            using (var connection = this.GetConnection())
            using (var command = connection.Connection.CreateCommand())
            {
                // from http://stackoverflow.com/questions/59444/how-do-you-check-what-version-of-sql-server-for-a-database-using-tsql
                command.CommandText = @"SELECT SERVERPROPERTY('productversion')";
                var result = (string)command.ExecuteScalar();
                var majorVersion = int.Parse(result.Split('.')[0]);
                return majorVersion >= 11 ? Version.Sql2012 : Version.Sql2008;
            }
        }

        /// <summary>
        /// Maps <see cref="ODataExpressionType"/>s to SqlServer types
        /// </summary>
        protected internal override string GetSqlTypeName(ODataExpressionType oDataType)
        {
            switch (oDataType) 
            {
                case ODataExpressionType.Binary:
                    return "VARBINARY(MAX)";
                case ODataExpressionType.Boolean:
                    return "BIT";
                case ODataExpressionType.Byte:
                    return "TINYINT";
                case ODataExpressionType.DateTime:
                    return "DATETIME";
                case ODataExpressionType.DateTimeOffset:
                    return "DATETIMEOFFSET";
                case ODataExpressionType.Decimal:
                    // basing this off NHibernate mapping referenced here 
                    // http://stackoverflow.com/questions/3152439/what-is-a-good-mapping-of-net-decimal-to-sql-server-decimal
                    return "DECIMAL(19, 5)";
                case ODataExpressionType.Double:
                    return "FLOAT";
                case ODataExpressionType.Guid:
                    return "UNIQUEIDENTIFIER";
                case ODataExpressionType.Int16:
                    return "SMALLINT";
                case ODataExpressionType.Int32:
                    return "INT";
                case ODataExpressionType.Int64:
                    return "BIGINT";
                case ODataExpressionType.Single:
                    // based on http://stackoverflow.com/questions/546150/float-in-database-to-in-net
                    return "REAL";
                case ODataExpressionType.String:
                    return "NVARCHAR(MAX)";
                case ODataExpressionType.Time:
                    return "TIME";
                default:
                    throw new NotSupportedException("OData type " + oDataType + " cannot be translated to SQL");
            }
        }

        /// <summary>
        /// Returns false: SqlServer has LTRIM and RTRIM
        /// </summary>
        protected internal override bool HasTwoSidedTrim { get { return false; } }

        /// <summary>
        /// Uses [] escaping
        /// </summary>
        protected internal override void RenderColumnName(Action<string> writer, PropertyInfo member)
        {
            var escaped = string.Format("[{0}]", member.Name.Replace("]", "]]"));
            writer(escaped);
        }

        /// <summary>
        /// Uses the DATEPART function
        /// </summary>
        protected internal override void RenderDatePartFunctionCall(ODataFunction datePartFunction, Action<string> writer, Action renderArgument)
        {
            writer("DATEPART(");
            writer(this.GetDatePartString(datePartFunction));
            writer(", ");
            renderArgument();
            writer(")");
        }

        /// <summary>
        /// Uses the CHARINDEX functino
        /// </summary>
        protected internal override void RenderIndexOfFunctionCall(Action<string> writer, Action renderNeedleArgument, Action renderHaystackArgument)
        {
            writer("(CHARINDEX(");
            renderNeedleArgument();
            writer(", ");
            renderHaystackArgument();
            writer("), -1)");
        }

        /// <summary>
        /// Uses <see cref="DatabaseProvider.PaginationSyntax.OffsetFetch"/> for <see cref="Version.Sql2012"/> and <see cref="DatabaseProvider.PaginationSyntax.RowNumber"/>
        /// for <see cref="Version.Sql2008"/>
        /// </summary>
        protected internal override DatabaseProvider.PaginationSyntax Pagination
        {
            get { return this.version.Value == Version.Sql2012 ? PaginationSyntax.OffsetFetch : PaginationSyntax.RowNumber; }
        }

        /// <summary>
        /// Uses the '%' operator
        /// </summary>
        protected internal override void RenderModuloOperator(Action<string> writer, Action renderLeftOperand, Action renderRightOperand)
        {
            writer("(");
            renderLeftOperand();
            writer(" % ");
            renderRightOperand();
            writer(")");
        }

        /// <summary>
        /// Renders @<see cref="Parameter.Name"/>
        /// </summary>
        protected internal override void RenderParameterReference(Action<string> writer, Parameter parameter)
        {
            writer("@");
            writer(parameter.Name);
        }

        /// <summary>
        /// Uses the ROUND function
        /// </summary>
        protected internal override void RenderRoundFunctionCall(Action<string> writer, Action renderArgument)
        {
            writer("ROUND(");
            renderArgument();
            writer(", 0)");
        }

        /// <summary>
        /// Uses the SUBSTRING function
        /// </summary>
        protected internal override void RenderSubstringFunctionCall(Action<string> writer, Action renderOriginalStringArgument, Action renderStartingPositionArgument, Action renderLengthArgument)
        {
            writer("SUBSTRING(");
            renderOriginalStringArgument();
            writer(", ");
            renderStartingPositionArgument();
            writer(" + 1");
            if (renderLengthArgument != null)
            {
                writer(", ");
                renderLengthArgument();
            }
            writer(")");
        }

        /// <summary>
        /// Uses the LEN function
        /// </summary>
        protected internal override string StringLengthFunctionName { get { return "LEN"; } }

        /// <summary>
        /// Executes SQL using this provider's connection factory. <see cref="ODataEntity"/> and types with default constructors
        /// can be materialized
        /// </summary>
        protected internal override IEnumerable Execute(string sql, IReadOnlyList<Parameter> parameters, Type resultType)
        {
            using (var connection = this.GetConnection())
            using (var command = connection.Connection.CreateCommand())
            {
                command.CommandText = sql;
                foreach (var parameter in parameters)
                {
                    var dbParameter = command.CreateParameter();
                    dbParameter.ParameterName = parameter.Name;
                    dbParameter.Value = parameter.Value ?? DBNull.Value;
                    command.Parameters.Add(dbParameter);
                }

                using (var reader = command.ExecuteReader())
                {
                    Func<DbDataReader, object> materialize;
                    if (resultType == typeof(ODataEntity))
                    {
                        var columnNames = reader.GetSchemaTable().Columns.Cast<DataColumn>()
                            .Select(c => c.ColumnName)
                            .ToArray();
                        materialize = r =>
                        {
                            var kvpArray = new KeyValuePair<string, object>[columnNames.Length];
                            for (var i = 0; i < kvpArray.Length; ++i)
                            {
                                kvpArray[i] = KeyValuePair.Create(columnNames[i], r.IsDBNull(i) ? null : r.GetValue(i));
                            }
                            return new ODataEntity(kvpArray);
                        };
                    }
                    else if (resultType.GetConstructor(Type.EmptyTypes) != null)
                    {
                        // TODO FUTURE offer faster compiled materialization (should optimize for cold start and cache, though!)
                        var ordinalPropertyMapping = reader.GetSchemaTable().Columns.Cast<DataColumn>()
                            .Select((c, index) => KeyValuePair.Create(index, resultType.GetProperty(c.ColumnName, BindingFlags.Public | BindingFlags.Instance)))
                            .Where(kvp => kvp.Value != null)
                            .ToArray();
                        materialize = r =>
                        {
                            var obj = Activator.CreateInstance(resultType);
                            for (var i = 0; i < ordinalPropertyMapping.Length; ++i)
                            {
                                var propMapping = ordinalPropertyMapping[i];
                                var value = reader.IsDBNull(propMapping.Key) ? null : reader.GetValue(propMapping.Key);
                                propMapping.Value.SetValue(obj, value);
                            }
                            return obj;
                        };
                    }
                    else
                    {
                        throw new NotSupportedException("Unable to materialize type " + resultType + ": it lacks a default constructor and is not " + typeof(ODataEntity));
                    }

                    while (reader.Read())
                    {
                        yield return materialize(reader);
                    }
                }
            }
        }

        /// <summary>
        /// Executes a count query using this provider's connection factory
        /// </summary>
        protected internal override int ExecuteCount(string sql, IReadOnlyList<Parameter> parameters)
        {
            throw new NotImplementedException();
        }
    }
}
