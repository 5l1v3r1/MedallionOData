using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using Medallion.OData.Trees;
using Newtonsoft.Json;

using PropertyPath = System.Collections.Generic.IReadOnlyList<System.Reflection.PropertyInfo>;

namespace Medallion.OData.Service
{
	internal interface IODataQuerySerializer
	{
		string Serialize<T>(IQueryable<T> query, IReadOnlyList<ODataSelectColumnExpression> select);
	}

	internal class ODataQueryJsonSerializer : IODataQuerySerializer
	{
		string IODataQuerySerializer.Serialize<T>(IQueryable<T> query, IReadOnlyList<ODataSelectColumnExpression> select)
		{
			return "";
		}

		// TODO add contract resolver to prevent types with pre-specified serializers
		// or just be OK with that

		private class JsonComplexTypeConverter : JsonConverter
		{
			private readonly List<PropertyInfo> _currentPath = new List<PropertyInfo>();
			private readonly IReadOnlyList<IReadOnlyList<PropertyInfo>> _selectedPaths; 

			public override bool CanConvert(Type objectType)
			{
				return objectType.ToODataExpressionType() == ODataExpressionType.Complex;
			}

			public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
			{
				throw new NotImplementedException();
			}

			public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
			{
				// make sure we're on the expected path
				var type = value.GetType();
				Throw<InvalidOperationException>.If(
					this._currentPath.Count > 0 && !this._currentPath[this._currentPath.Count - 1].PropertyType.IsAssignableFrom(type),
					() => string.Format("Trying to serialize type {0} in the context of path {1}", type, this._currentPath.ToDelimitedString("."))
				);
				
				var properties = type.GetProperties();
				writer.WriteStartObject();
				foreach (var prop in properties)
				{
					if (prop.PropertyType.ToODataExpressionType() == ODataExpressionType.Complex)
					{
					}
				}
				writer.WriteEndObject();
			}
		}

		#region ---- Projection type ----
		/* Generated by
		 var range = Enumerable.Range(1, 10);
string.Format(@"private static readonly object Projection = new {{ {0} }};",
	range.Select(i => "T" + i + " = default(bool)").ToDelimitedString(", "))
	.Dump();;
		 */
		private static readonly object Projection = new { T1 = default(bool), T2 = default(bool), T3 = default(bool), T4 = default(bool), T5 = default(bool), T6 = default(bool), T7 = default(bool), T8 = default(bool), T9 = default(bool), T10 = default(bool) };
		private static readonly Type ProjectionType = Projection.GetType().GetGenericTypeDefinition();
		private static readonly IReadOnlyList<PropertyInfo> ProjectionTypeProperties = ProjectionType.GetProperties();
        private static readonly IEqualityComparer<PropertyPath> PathComparer = EqualityComparers.Create<PropertyPath>((p1, p2) => p1.SequenceEqual(p2, Helpers.MemberComparer), p => p.Aggregate(0, (h, pi) => h ^ Helpers.MemberComparer.GetHashCode(pi)));

		private static Dictionary<PropertyPath, PropertyPath> BuildMapping(IEnumerable<PropertyPath> paths)
		{
			var result = new Dictionary<PropertyPath, PropertyPath>();
			var nextProperty = 0;
			var nextPropertyNestLevel = 0;
			foreach (var path in paths)
			{
				result.Add(path, Enumerable.Repeat(ProjectionTypeProperties[ProjectionTypeProperties.Count - 1], nextPropertyNestLevel).Concat(ProjectionTypeProperties[nextProperty].Enumerate()).ToArray());
				if (nextProperty == ProjectionTypeProperties.Count - 1)
				{
					nextPropertyNestLevel++;
					nextProperty = 0;
				}
			}

			return result;
		}
	}
    #endregion
}
