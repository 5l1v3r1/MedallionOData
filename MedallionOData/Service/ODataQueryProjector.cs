using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using Medallion.OData.Trees;
using PropertyPath = System.Collections.Generic.IReadOnlyList<System.Reflection.PropertyInfo>;

namespace Medallion.OData.Service
{
    /// <summary>
    /// The purpose of this class is to allow the specific selected columns to be retrieved from the query
    /// </summary>
    internal class ODataQueryProjector
    {
        /* Generated by
string.Format(
	@"private static readonly object Projection = new {{ {0} }};",
    string.Join(", ", Enumerable.Range(1, 10).Select(i => "T" + i + " = default(int)"))
)
.Dump();
         */
        private static readonly object Projection = new { T1 = default(int), T2 = default(int), T3 = default(int), T4 = default(int), T5 = default(int), T6 = default(int), T7 = default(int), T8 = default(int), T9 = default(int), T10 = default(int) }; 
        private static readonly Type ProjectionType = Projection.GetType().GetGenericTypeDefinition();
        private static readonly IReadOnlyList<PropertyInfo> ProjectionTypeProperties = ProjectionType.GetProperties();
        private static readonly IEqualityComparer<PropertyPath> PathComparer = EqualityComparers.Create<PropertyPath>(
            (p1, p2) => p1.SequenceEqual(p2, Helpers.MemberComparer),
            p => p.Aggregate(0, (h, pi) => h ^ Helpers.MemberComparer.GetHashCode(pi))
        );

        public static Result Project(IQueryable query, IReadOnlyList<ODataSelectColumnExpression> select)
        {
            if (select.Count == 0)
            {
                return Project(query, new[] { ODataExpression.SelectStar() });
            }

            Throw<NotSupportedException>.If(select.Any(sc => !sc.AllColumns && sc.Type == ODataExpressionType.Complex), "Selecting a complex type is only supported when selecting all columns of that type (with '/*')");

            var mapping = BuildMapping(select);

            var parameter = Expression.Parameter(query.ElementType);
            var newExpression = BuildNewExpression(parameter, mapping);
            var lambda = Expression.Lambda(newExpression, parameter);
            var selectMethod = Helpers.GetMethod((IQueryable<object> q) => q.Select(o => o))
                .GetGenericMethodDefinition()
                .MakeGenericMethod(query.ElementType, newExpression.Type);
            var projected = (IQueryable)selectMethod.Invoke(null, new object[] { query, lambda });

            var resultMapping = BuildResultMapping(projected.ElementType, mapping);

            return new Result(projected, resultMapping);
        }

        private static NewExpression BuildNewExpression(ParameterExpression rootParameter, IReadOnlyDictionary<PropertyPath, ODataSelectColumnExpression> mapping)
        {
            // all paths longer than length 1 get grouped together and mapped to their own expression (this lets us support an arbitrary number of selected columns)
            var nestedProperties = mapping.Where(kvp => kvp.Key.Count > 1).ToArray();
            var nestedExpression = nestedProperties.Length > 0
                ? BuildNewExpression(rootParameter, nestedProperties.ToDictionary(kvp => kvp.Key.Skip(1).ToArray().As<PropertyPath>(), kvp => kvp.Value, PathComparer))
                : Expression.Constant(false).As<Expression>();

            // gather all argument expressions which will be used to initialize the type
            var arguments = ProjectionTypeProperties.Take(ProjectionTypeProperties.Count - 1)
                .Select(prop => 
                {
                    ODataSelectColumnExpression selectColumn;
                    if (!mapping.TryGetValue(new[] { prop }, out selectColumn)) 
                    {
                        return Expression.Constant(false);
                    }
                    
                    var selectColumnPropertyPath = Traverse.Along(selectColumn.Expression, c => c.Expression)
                        .Select(m => m.Member)
                        .Reverse();
                    var expression = selectColumnPropertyPath.Aggregate(rootParameter.As<Expression>(), (acc, pi) => Expression.MakeMemberAccess(acc, pi));
                    return expression;
                })
                .ToList();
            arguments.Add(nestedExpression);

            // build the new expression
            var parameterizedType = ProjectionType.MakeGenericType(arguments.Select(a => a.Type).ToArray());
            var newExpression = Expression.New(
                parameterizedType.GetConstructors().Single(),
                arguments
            );
            return newExpression;
        }

        /// <summary>
        /// Maps the paths in the projected type to the various select columns
        /// </summary>
        private static Dictionary<PropertyPath, ODataSelectColumnExpression> BuildMapping(IEnumerable<ODataSelectColumnExpression> selectPaths)
        {
            // allocate each property in order, reserving the last one. When we get to the last one, start allocating nested properties. For
            // example, if we had only 3 properties a, b, c, we'd allocate a, b, c.a, c.b, c.c.a, c.c.b, ...
            var result = new Dictionary<PropertyPath, ODataSelectColumnExpression>(PathComparer);
            var nextProperty = 0;
            var nextPropertyNestLevel = 0;
            foreach (var selectPath in selectPaths)
            {
                var nextAvailableProjectPath = Enumerable.Repeat(ProjectionTypeProperties[ProjectionTypeProperties.Count - 1], nextPropertyNestLevel)
                    .Concat(ProjectionTypeProperties[nextProperty].Enumerate())
                    .ToArray();
                result.Add(nextAvailableProjectPath, selectPath);
                if (nextProperty == ProjectionTypeProperties.Count - 2)
                {
                    nextPropertyNestLevel++;
                    nextProperty = 0;
                }
                else
                {
                    nextProperty++;
                }
            }

            return result;
        }

        #region ---- Build Result Mapping ----
        private static Dictionary<ODataSelectColumnExpression, PropertyPath> BuildResultMapping(Type resultType, IReadOnlyDictionary<PropertyPath, ODataSelectColumnExpression> mapping)
        {
            return mapping.ToDictionary(kvp => kvp.Value, kvp => MakeGenericPropertyPath(kvp.Key, resultType));
        }

        private static PropertyPath MakeGenericPropertyPath(PropertyPath path, Type resultType)
        {
            var replacementProperty = resultType.GetProperty(path[0].Name, BindingFlags.Public | BindingFlags.Instance);
            Throw<InvalidOperationException>.If(replacementProperty == null, "sanity check");

            var result = new List<PropertyInfo> { replacementProperty };
            if (path.Count > 1)
            {
                result.AddRange(MakeGenericPropertyPath(path.Skip(1).ToArray(), replacementProperty.PropertyType));
            }
            return result.AsReadOnly();
        }
        #endregion

        public class Result : Tuple<IQueryable, IReadOnlyDictionary<ODataSelectColumnExpression, PropertyPath>>
        {
            internal Result(IQueryable query, IReadOnlyDictionary<ODataSelectColumnExpression, PropertyPath> mapping)
                : base(query, mapping)
            {
                Throw.IfNull(query, "query");
                Throw.IfNull(mapping, "mapping");
            }

            public IQueryable Query { get { return this.Item1; } }
            public IReadOnlyDictionary<ODataSelectColumnExpression, PropertyPath> Mapping { get { return this.Item2; } }
        }
    }
}
